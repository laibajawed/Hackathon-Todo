# Implementation Plan: Todo Full-Stack Web Application (Basic Level)

**Branch**: `001-fullstack-web-todo` | **Date**: 2026-01-13 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-fullstack-web-todo/spec.md`

## Summary

Transform the Phase 1 console todo application into a multi-user web application with authentication, RESTful API, and responsive frontend. The system will support user registration/authentication via Better Auth with JWT tokens, provide REST API endpoints for all CRUD operations (Create, Read, Update, Delete, Toggle Complete), persist data in Neon PostgreSQL, and deliver a responsive Next.js frontend with Tailwind CSS styling. All work is contained within the /phase-2 folder following a monorepo structure with clear frontend/backend separation.

## Technical Context

**Language/Version**:
- Backend: Python 3.13+
- Frontend: TypeScript (via Next.js 16+)

**Primary Dependencies**:
- Backend: FastAPI, SQLModel, Better Auth (JWT verification), Pydantic, uvicorn
- Frontend: Next.js 16+ (App Router), React, Better Auth (JWT plugin), Tailwind CSS, TypeScript

**Storage**: Neon Serverless PostgreSQL (cloud-hosted PostgreSQL)

**Testing**:
- Backend: pytest, pytest-asyncio, httpx (for API testing)
- Frontend: Jest, React Testing Library

**Target Platform**: Web application (browser-based), WSL 2 compatible for development

**Project Type**: Web (frontend + backend monorepo)

**Performance Goals**:
- API response times: <500ms for typical operations (p95)
- Page load times: <3 seconds on standard broadband
- Concurrent users: Support at least 100 concurrent users
- Task operations: <2 seconds from action to UI update

**Constraints**:
- All work must be contained within /phase-2 folder
- JWT tokens required for all API requests (no anonymous access)
- User data isolation enforced at database query level
- No shared data across users without explicit authorization
- Must use specified tech stack (no substitutions)
- Responsive design: 320px to 1920px width support

**Scale/Scope**:
- Multi-user web application (100+ users expected)
- 6 user stories (3 P1, 2 P2, 1 P3)
- 18 functional requirements
- 5 REST API endpoints (GET, POST, PUT, DELETE, PATCH)
- 3 main UI components (TaskList, TaskForm, tasks page)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### ✅ I. Spec-First, Code-Second
**Status**: PASS
- Specification created and validated in specs/001-fullstack-web-todo/spec.md
- This plan follows the spec → plan → tasks → implementation sequence
- No implementation exists yet

### ✅ II. Zero Boilerplate
**Status**: PASS
- All code will be generated by AI agents via Claude Code
- No manual coding permitted
- Scaffolding, configuration, and implementation all agent-generated

### ✅ III. Deterministic Evolution
**Status**: PASS
- This is Phase 2 (Web UI) following Phase 1 (CLI console app)
- Logical progression: CLI → Web UI → Chatbot (Phase 3) → Event-Driven (Phase 4) → Cloud (Phase 5)
- No phases skipped or merged

### ⚠️ IV. Agent-Native Design (MCP-First)
**Status**: JUSTIFIED DEVIATION
- **Constitutional Requirement**: "All services expose tools via Model Context Protocol (MCP) before implementing UI layers"
- **Deviation**: Phase 2 implements web UI without MCP layer
- **Justification**:
  - MCP integration is explicitly scoped for Phase 3 (Chatbot Integration)
  - Phase 2 focuses on establishing web infrastructure (auth, API, UI) that Phase 3 will build upon
  - The REST API endpoints created in Phase 2 will be wrapped with MCP tools in Phase 3
  - This follows the deterministic evolution principle: establish web foundation before adding AI interaction layer
- **Mitigation**: REST API design will be MCP-compatible (stateless, clear contracts, proper error handling)

### ✅ Technology Stack Compliance
**Status**: PASS
- Backend: Python 3.13+ with FastAPI ✅
- Data Layer: SQLModel ORM on Neon PostgreSQL ✅
- Frontend: Next.js 16+ with React ✅
- Runtime: WSL 2 compatible ✅

### ✅ Authentication & Authorization
**Status**: PASS
- JWT-based Better Auth implementation planned
- User isolation enforced at database query level (user_id filtering)
- Multi-tenancy: Every data access validates user context
- No shared data across users without explicit authorization

### N/A Deployment Architecture
**Status**: NOT APPLICABLE
- Kubernetes deployment is Phase 4 (out of scope for Phase 2)
- Phase 2 focuses on local development environment
- Will run locally via npm/uvicorn for development

### ✅ Development Workflow
**Status**: PASS
- All code generation via AI-assisted tools (Claude Code)
- Following Spec-Kit Plus workflow conventions
- No manual scripts or configurations

**Constitution Check Result**: PASS with 1 justified deviation (MCP-First deferred to Phase 3)

## Project Structure

### Documentation (this feature)

```text
specs/001-fullstack-web-todo/
├── spec.md              # Feature specification (completed)
├── plan.md              # This file (in progress)
├── research.md          # Phase 0 output (to be generated)
├── data-model.md        # Phase 1 output (to be generated)
├── quickstart.md        # Phase 1 output (to be generated)
├── contracts/           # Phase 1 output (to be generated)
│   ├── openapi.yaml     # REST API OpenAPI specification
│   └── auth-flow.md     # Authentication flow documentation
├── checklists/          # Quality validation checklists
│   └── requirements.md  # Specification quality checklist (completed)
└── tasks.md             # Phase 2 output (NOT created by /sp.plan - use /sp.tasks)
```

### Source Code (repository root)

```text
phase-2/
├── backend/
│   ├── main.py                 # FastAPI application entry point
│   ├── models.py               # SQLModel database models (User, Task)
│   ├── database.py             # Database connection and session management
│   ├── config.py               # Configuration (env vars, settings)
│   ├── auth/
│   │   ├── __init__.py
│   │   ├── jwt.py              # JWT verification middleware
│   │   ├── dependencies.py     # FastAPI dependencies (get_current_user)
│   │   └── schemas.py          # Auth request/response schemas
│   ├── routes/
│   │   ├── __init__.py
│   │   ├── auth.py             # Authentication endpoints (signup, signin)
│   │   └── tasks.py            # Task CRUD endpoints
│   ├── tests/
│   │   ├── __init__.py
│   │   ├── conftest.py         # Pytest fixtures
│   │   ├── test_auth.py        # Authentication tests
│   │   └── test_tasks.py       # Task API tests
│   ├── requirements.txt        # Python dependencies
│   └── .env.example            # Environment variables template
│
├── frontend/
│   ├── app/
│   │   ├── layout.tsx          # Root layout with auth provider
│   │   ├── page.tsx            # Landing/home page
│   │   ├── auth/
│   │   │   ├── signin/
│   │   │   │   └── page.tsx    # Sign in page
│   │   │   └── signup/
│   │   │       └── page.tsx    # Sign up page
│   │   └── tasks/
│   │       └── page.tsx        # Main task management page
│   ├── components/
│   │   ├── TaskList.tsx        # Task list display component
│   │   ├── TaskForm.tsx        # Task creation/editing form
│   │   ├── TaskItem.tsx        # Individual task item component
│   │   └── AuthGuard.tsx       # Protected route wrapper
│   ├── lib/
│   │   ├── api.ts              # API client with JWT handling
│   │   ├── auth.ts             # Better Auth configuration
│   │   └── types.ts            # TypeScript type definitions
│   ├── hooks/
│   │   ├── useTasks.ts         # Task data fetching hook
│   │   └── useAuth.ts          # Authentication state hook
│   ├── tests/
│   │   ├── components/         # Component tests
│   │   └── integration/        # Integration tests
│   ├── public/                 # Static assets
│   ├── tailwind.config.js      # Tailwind CSS configuration
│   ├── tsconfig.json           # TypeScript configuration
│   ├── package.json            # Node dependencies
│   ├── next.config.js          # Next.js configuration
│   └── .env.local.example      # Environment variables template
│
├── README.md                   # Setup and installation instructions
├── CLAUDE.md                   # Claude Code usage guidelines
└── docker-compose.yml          # Optional: Local development environment
```

**Structure Decision**: Selected Option 2 (Web application) with frontend/backend separation. This structure:
- Clearly separates concerns between API and UI layers
- Supports independent development and testing of each layer
- Aligns with monorepo organization specified in requirements
- Facilitates future scaling (e.g., adding mobile clients, microservices)
- Maintains all Phase 2 work within /phase-2 folder as required

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| MCP-First (Phase 2 implements UI before MCP) | Phase 2 establishes web infrastructure (auth, API, UI) that Phase 3 will build upon with MCP integration | Implementing MCP in Phase 2 would violate Deterministic Evolution principle by merging Phase 2 (Web UI) and Phase 3 (Chatbot/MCP) |

## Architecture Decisions

### 1. Authentication Strategy

**Decision**: Use Better Auth library with JWT plugin for both frontend and backend

**Rationale**:
- Better Auth provides production-ready JWT implementation
- Supports both client-side (Next.js) and server-side (FastAPI) validation
- Handles token refresh, expiration, and secure storage
- Reduces custom authentication code and security risks

**Alternatives Considered**:
- Custom JWT implementation: Rejected due to security complexity and maintenance burden
- Session-based auth: Rejected due to scalability concerns and REST API statelessness requirements
- OAuth2 only: Rejected as out of scope for Phase 2 (email/password required)

**Implementation Notes**:
- JWT secret must be shared between frontend and backend via environment variables
- Tokens stored in httpOnly cookies on frontend for XSS protection
- Backend validates JWT signature and expiration on every protected endpoint
- User ID extracted from JWT claims for database query filtering

### 2. Database Schema Design

**Decision**: Two-table schema with User and Task entities, enforcing user isolation via foreign keys

**Rationale**:
- Simple schema matches Phase 2 scope (no categories, tags, or sharing)
- Foreign key relationship ensures referential integrity
- User ID in Task table enables efficient filtering and isolation
- Supports all CRUD operations without complex joins

**Schema**:
```sql
User:
  - id: UUID (primary key)
  - email: String (unique, indexed)
  - password_hash: String
  - created_at: Timestamp
  - updated_at: Timestamp

Task:
  - id: UUID (primary key)
  - user_id: UUID (foreign key to User.id, indexed)
  - title: String (max 200 chars, not null)
  - description: String (max 2000 chars, nullable)
  - status: Enum('pending', 'completed')
  - created_at: Timestamp
  - updated_at: Timestamp
```

**Alternatives Considered**:
- Single table with user data embedded: Rejected due to data duplication and update anomalies
- Separate database per user: Rejected as over-engineering for Phase 2 scale
- NoSQL document store: Rejected as constitution mandates PostgreSQL

### 3. API Design Pattern

**Decision**: RESTful API with resource-based endpoints following standard HTTP methods

**Endpoints**:
```
POST   /api/auth/signup          # Create new user account
POST   /api/auth/signin          # Authenticate and receive JWT
GET    /api/tasks                # List all tasks for authenticated user
POST   /api/tasks                # Create new task
GET    /api/tasks/{id}           # Get single task (optional, for future use)
PUT    /api/tasks/{id}           # Update task title/description
PATCH  /api/tasks/{id}/toggle    # Toggle task completion status
DELETE /api/tasks/{id}           # Delete task
```

**Rationale**:
- REST is industry standard, well-understood, and MCP-compatible
- Resource-based URLs are intuitive and cacheable
- HTTP methods map naturally to CRUD operations
- Separate PATCH endpoint for toggle operation follows single-responsibility principle

**Alternatives Considered**:
- GraphQL: Rejected as over-engineering for simple CRUD operations
- RPC-style endpoints: Rejected as less RESTful and harder to cache
- Single /api/tasks endpoint with action parameter: Rejected as non-standard

### 4. Frontend State Management

**Decision**: React hooks (useState, useEffect) with custom hooks for data fetching, no global state library

**Rationale**:
- Phase 2 scope is simple enough for local component state
- Custom hooks (useTasks, useAuth) provide reusability without library overhead
- Reduces bundle size and complexity
- Easier for AI agents to generate and maintain

**Alternatives Considered**:
- Redux/Redux Toolkit: Rejected as over-engineering for current scope
- Zustand/Jotai: Rejected as unnecessary for Phase 2 (may revisit in Phase 3)
- React Context: Rejected as hooks are sufficient for current needs

### 5. Error Handling Strategy

**Decision**: Consistent error response format with HTTP status codes and user-friendly messages

**Backend Error Format**:
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Task title cannot be empty",
    "details": { "field": "title" }
  }
}
```

**Frontend Error Handling**:
- API client catches errors and extracts user-friendly messages
- Toast notifications for transient errors
- Inline form validation for input errors
- Fallback error boundary for unexpected errors

**Rationale**:
- Consistent format simplifies frontend error handling
- User-friendly messages improve UX (FR-015)
- HTTP status codes enable proper caching and retry logic
- Detailed error information aids debugging

## Phase 0: Research & Technology Validation

### Research Tasks

1. **Better Auth Integration with FastAPI**
   - Research: How to validate Better Auth JWT tokens in FastAPI middleware
   - Research: JWT secret sharing between Next.js and FastAPI
   - Research: Token extraction from Authorization header vs cookies

2. **Next.js 16+ App Router with Better Auth**
   - Research: Better Auth setup with Next.js App Router (not Pages Router)
   - Research: JWT plugin configuration and token storage
   - Research: Protected routes implementation in App Router

3. **SQLModel with Neon PostgreSQL**
   - Research: Neon connection string format and SSL requirements
   - Research: SQLModel async support with FastAPI
   - Research: Database migration strategy (Alembic vs SQLModel)

4. **CORS Configuration**
   - Research: CORS setup for FastAPI to allow Next.js frontend requests
   - Research: Credentials handling with JWT in CORS requests

5. **Development Environment Setup**
   - Research: Running FastAPI and Next.js concurrently in development
   - Research: Environment variable management across frontend/backend
   - Research: Hot reload configuration for both services

### Expected Research Outputs

All research findings will be documented in `research.md` with:
- Decision made
- Rationale for decision
- Alternatives considered and why rejected
- Implementation guidance and code examples
- Links to official documentation

## Phase 1: Design Artifacts

### 1. Data Model (data-model.md)

Will document:
- Entity definitions (User, Task)
- Field specifications with types and constraints
- Relationships and foreign keys
- Indexes for query optimization
- Validation rules from functional requirements
- State transitions (pending ↔ completed)

### 2. API Contracts (contracts/)

Will generate:
- **openapi.yaml**: Complete OpenAPI 3.0 specification with:
  - All endpoint definitions
  - Request/response schemas
  - Authentication requirements (JWT bearer token)
  - Error response formats
  - Example requests and responses

- **auth-flow.md**: Authentication flow documentation with:
  - Signup flow diagram
  - Signin flow diagram
  - JWT token lifecycle
  - Token refresh strategy (if applicable)
  - Error scenarios and handling

### 3. Quickstart Guide (quickstart.md)

Will provide:
- Prerequisites (Python 3.13+, Node.js 18+, Neon account)
- Environment setup instructions
- Database provisioning steps
- Backend setup and running instructions
- Frontend setup and running instructions
- First-time user flow walkthrough
- Common troubleshooting tips

### 4. Agent Context Update

Will run `.specify/scripts/bash/update-agent-context.sh claude` to:
- Add Phase 2 technologies to CLAUDE.md
- Document new dependencies (Better Auth, Tailwind CSS)
- Update active technologies section
- Preserve manual additions between markers

## Implementation Phases (Post-Planning)

### Phase 2: Task Breakdown (via /sp.tasks)

After this plan is complete, run `/sp.tasks` to generate:
- Granular, testable tasks for each component
- Task dependencies and execution order
- Acceptance criteria per task
- Test cases for each task

### Phase 3: Implementation (via /sp.implement)

After tasks are generated, run `/sp.implement` to:
- Execute tasks in dependency order
- Generate all code via AI agents
- Run tests after each task
- Validate acceptance criteria

## Risk Analysis

### High-Priority Risks

1. **Better Auth JWT Integration Complexity**
   - Risk: Better Auth may not have clear FastAPI integration examples
   - Mitigation: Research phase will validate integration approach; fallback to standard JWT libraries if needed
   - Impact: Could delay backend authentication implementation

2. **User Isolation Enforcement**
   - Risk: Missing user_id filter in queries could leak data across users
   - Mitigation: Create FastAPI dependency that automatically injects user_id from JWT; code review all queries
   - Impact: Critical security vulnerability if not handled correctly

3. **CORS Configuration Issues**
   - Risk: Incorrect CORS setup could block frontend-backend communication
   - Mitigation: Research phase will document correct CORS configuration; test with actual requests
   - Impact: Could block all API calls from frontend

### Medium-Priority Risks

4. **Neon PostgreSQL Connection Stability**
   - Risk: Serverless database may have cold start delays or connection limits
   - Mitigation: Implement connection pooling; handle connection errors gracefully
   - Impact: Could affect API response times

5. **JWT Token Expiration Handling**
   - Risk: Expired tokens could cause poor UX if not handled gracefully
   - Mitigation: Implement token refresh or clear error messages; research Better Auth token refresh
   - Impact: Users may need to re-login frequently

### Low-Priority Risks

6. **TypeScript Type Mismatches**
   - Risk: Frontend types may not match backend API responses
   - Mitigation: Generate TypeScript types from OpenAPI spec; validate with tests
   - Impact: Runtime errors in frontend

## Success Criteria

This plan is successful when:

1. ✅ All research tasks completed and documented in research.md
2. ✅ Data model documented with complete entity definitions
3. ✅ OpenAPI specification generated with all endpoints
4. ✅ Authentication flow documented with diagrams
5. ✅ Quickstart guide provides clear setup instructions
6. ✅ Agent context updated with Phase 2 technologies
7. ✅ Constitution check re-validated after design phase
8. ✅ No unresolved NEEDS CLARIFICATION items remain
9. ✅ All architectural decisions documented with rationale
10. ✅ Risk analysis identifies mitigation strategies

## Next Steps

1. **Immediate**: Execute Phase 0 research tasks
2. **After Research**: Generate Phase 1 design artifacts
3. **After Design**: Re-validate Constitution Check
4. **After Planning**: Run `/sp.tasks` to generate task breakdown
5. **After Tasks**: Run `/sp.implement` to execute implementation

---

**Plan Status**: Ready for Phase 0 Research
**Last Updated**: 2026-01-13
**Next Command**: Begin Phase 0 research task execution
